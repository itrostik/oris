---
title: первый
---
# Билет
HTTP-протокол (методы запросов, тело запроса, тело ответа, параметры запроса, заголовки, статусные коды ответа, общая логика протокола), cookie, основные заголовки. Защита от повторной отправки форм
# HTTP-протокол
## Определение сетевого протокола
Сетевой протокол - набор правил, действий, форматов, регламентирующий обмен данными между узлами сети

## Три типа протоколов
- **Симплексный режим**: односторонняя связь (телевизор, проектор, клавиатура)
- **Полудуплексный режим**: в определенный момент времени передача данных только в одну сторону (HTTP)
- **Полнодуплексный режим**: в определенный момент времени передача данных в обе стороны (WebSocket)

## Определение
Полудуплексный протокол обмена данными. Протокол прикладного уровня ([[Девятый|7 уровень OSI]])

## Схема работы
- Клиент формирует запрос и отправляет его на сервер
- После чего сервер обрабатывает полученный запрос
- Формирует ответ на него его и отправляет обратно клиенту

## Методы запросов
- **GET** - запрашивает ответ у сервера по заданному URI
- **POST** - позволяет отправить данные на сервер
- **PUT** - используется для создания (размещения) новых ресурсов на сервере
- **PATCH** - используется для частичного изменения ресурса
- **DELETE** - позволяет удалить существующие ресурсы на сервере
- **HEAD** - работает как GET, но в ответ сервер посылает только заголовки и статусную строку без тела HTTP сообщения
- **OPTIONS** - для получения параметров текущего HTTP соединения
- **TRACE** - создает петлю, благодаря которой клиент может увидеть, что происходит с сообщением на всех узлах передачи
- **CONNECT** - преобразует текущее соединение в тоннель

## Запрос
### Cхема запроса
```
METHOD path Protocol
Header-name: header-value
Header-name: header-value

Body
```

### Структура запроса
1. Стартовая строка. В нее входит:
	1. Название метода `METHOD`
	2. URI путь `path`
	3. Название протокола `Protocol`
2. Заголовки запроса в виде ключ-значение
3. Пустая строка
4. Тело запроса (необязательно)

### Пример запроса
```
POST /forum/topic.php?id=42 HTTP/1.1  
Host: example.com  
Content-type: application/x-www-form-urlencoded Content-length: 375
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0
Accept: text/html, application/xhtml+xml, application/xml; q=0.9,*/*; q=0.8  
Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3  
Referer: https://www.google.ru/
Connection: keep-alive

text=Hello%20world&title=Post%20title........
```

### Query string
Дополнительная информация, передаваемая вместе с запросом. Передается прямо в URI в виде пары ключ-значение. Отделяется от основной части URI знаком `?`, а друг от друга символом `&`. Пример: `?peers=22929017&sel=136196802`.  Активно используется для GET-запросов. Также могут быть использованы и для других запросов, но иногда не подходят из-за объема данных. Поэтому для POST-запросов иногда используют тело запроса. Также иногда конфиденциальную информацию передают в теле запроса, чтобы информация не сохранялась в истории браузера по URI
## Ответ
### Схема ответа
```
Protocol CODE STATUS
Header-name: header-value
Header-name: header-value

Body
```

### Структура ответа
1. Стартовая строка. В нее входит:
	1. Название протокола `Protocol`
	2. [[#Статусные коды ответа]] `CODE`
	3. Статус ответа `STATUS`
2. Заголовки запроса в виде ключ-значение
3. Пустая строка
4. Тело запроса (необязательно)

### Пример ответа
```
HTTP/1.1 200 OK  
Date: Wed, 27 JUL 2016 11:20:59 GMT  
Server: Apache  
X-Powered-By: PHP/5.6.3-2ubuntu5wm1 Last-Modified: Wed, 27 JUL 2016 11:20:59 GMT Content-Language: ru  
Content-Type: text/html; charset=utf-8 Content-Length: 2437  
Connection: keep-alive

<!DOCTYPE html>
<html>  
...
```

## Статусные коды ответа
Код состояния - три цифры (первая указывает на класс состояния), которые определяют результат совершения запроса. Набор кодов состояния является стандартом.
- 1xx: Informational
	- 100 - Continue. Буквально говорит: "Продолжай работу". Иногда бывает полезен, например, когда сервер подлагивает или подтормаживает.
	- 101 - Switching Protocols. Указывает протокол, на который переключается сервер.
- 2xx: Success
	- 200 - OK
	- 201 - Created. Обычно используется при POST/PUT запросах, чтобы сказать, что ресурс был создан успешно.
	- 202 - Accepted. Указывает, что запрос получен, но ещё не обработан.
- 3xx: Redirection
	- 301 - Moved Permanently. Браузер **запоминает** эти движения и может начать редиректить, когда это не нужно, так что аккуратнее. Это означает, что если в будущем зайти по ссылке, браузер ничего запрашивать не будет и сразу перекинет по полученной ранее ссылке
	- 302 - Found. Браузер **не запоминает** эти движения, используется чаще всего
	- 303 - See other. Вроде всё обработано, но сервер такой: "Посмотри другой документ"
	- 304 - Not Modified. Позволяет не отдавать тело ответа, говоря браузеру забрать данные из кэша, так как они не изменялись
- 4xx: Client Error
	- 400 - Bad Request. Говорит о том, что запрос сформирован некорректно.
	- 401 - Unauthorized. Говорит о том, что пользователь не авторизован/вообще не представлялся.
	- 402 - Payment Required. Говорит о том, что нужна оплата (возможно, какой-то платный ресурс)
	- 403 - Forbidden. Обычно приходит, когда к какому-то ресурсу нет доступа.
	- 404 - Not Found. Говорит о том, что ресурс не найден.
	- 405 - Method Not Allowed. Допустим, если вы не реализовали метод doGet в сервлетах, тогда по умолчанию будет отправляться этот код, типа "Метод не используется".
	- 418 - I'm A Teapot. Первоапрельская шутка. Означает, что сервер не может приготовить кофе, потому что он чайник
	- 429 - Too Many Requests. Защита от частых запросов — своеобразная защита от DDoS-атак
	- 451 - Unavailable For Legal Reasons. Говорит о том, что ресурс запрещён для просмотра в вашей стране
- 5xx: Server Error
	- 500 - Internal Server Error. Внутренняя ошибка сервере. Скорее всего, сервер упал, ведь он перестаёт принимать запросы
	- 502 - Bad Gateway. Возникает при ошибках софта на сервере
	- 5xx - Пора фронтендеру идти бить по рукам бэкендера
# cookie
## Определение
Небольшой фрагмент данных, полученный сервером и сохраненный в памяти клиента (браузера). Всякий раз когда клиент обращается к серверу он отправляет куки следом в составе HTTP-запросе.
Куки - это коллекция из пар ключ-значение через `;`
С точки зрения HTTP-протокола куки - это заголовок

## Для чего нужны
1. Аутентификация (именно куки позволяют не вводить логин и пароль каждый раз при посещении сайта)
2. Мониторинг сеансов доступа
3. Хранение настроек и предпочтений (куки позволяют сделать HTTP-протокол statefull)
4. Статистика о пользователях

## Атрибуты
- `key` устанавливает имя cookie-файла
- `value` сохраняет значение cookie
- `expires` и `max-age` определяют срок жизни cookie, по истечению которого она будет автоматически удалена.
	- Объясняю прикол с единичкой в `max-age`
	- Если установить `max-age` в 0 или вообще не указывать (`expires` тоже не указан), то куки становится **сессионным**. То есть в теории он должен уничтожиться после закрытия клиента. Но есть один прикольчик. Сейчас браузеры умеют восстанавливать сессии. Поэтому даже после закрытия клиента куки может продолжать жить, так как после включения клиента, браузер "позаботится о нас" и восстановит сессию, из-за чего куки будет жить условно бесконечно, считая, что сессия не закончилась
	- Поэтому, чтобы удалить куки, нужно устанавливать `max-age` в 1. Тогда через секунду куки железобетонно удалится и браузер тут своей заботы проявлять не будет
	- С `expires` все попроще. Ставишь буквально дату, когда нужно удалить куки. Если поставить дату, которая уже случилась, то куки автоматом удалится
- `path` указывает путь к директории на сервере, для которой будут доступны cookie. Если указать корневой каталог /, то cookie будут доступны всему домену. По умолчанию значением является текущая директория, из которой cookie устанавливаются в браузер.
- `domain` отмечает, какой домен или поддомен имеет доступ к этой cookie. Для того, чтобы сделать cookie доступными для всего домена (включая поддомены), нужно просто указать имя домена (например example.com)

## Принцип работы
- Началась работа и был отправлен первый запрос серверу
	- Уже есть какие-то куки. Они отправляются вместе с первым запросом. На основе их (если это нужно) сервер возвращает свой ответ
	- Нет куки. Тогда простой HTTP-запрос отправляется на сервер
- Сервер на любой HTTP-запрос может ответить HTTP-ответом, где может присутствовать заголовок `Set-Cookie`, который говорит клиенту: "Будь так добр, добавь вот такой куки по-братски". Клиент отказаться не может или может при сильном желании. Добавленный куки используется в дальнейшем при каждом HTTP-запросе 

## Удаление куки
Метода `removeCookie` **не существует**

Поэтому, чтобы удалить куки, нужно отправить в ответ куки с нужным именем, но указать `max-age = 1` либо уже прошедший `expires`. ([[#Атрибуты|Почему max-age не 0?]]) 
## Cookie in Java
Метод `void addCookie(Cookie cookie)` у HttpServletResponse добавляет к ответу указанный cookie.
```Java
 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Servlet Expection, IOException {
	Cookie cookie = new Cookie("user", "Tom");
	resp.addCookie(cookie);
 }
```

Чтобы получить куки - используем `Cookie[] getCookies()` у HttpServletRequest
```Java
 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Servlet Expection, IOException {
	Cookie[] cookie = req.getCookies();
 }
```

# Основные заголовки
- `User-Agent` - Название браузера, его движка, OC (`Mozilla/5.0`)
- `Accept-Language` - Какие языки ожидаются браузером (`ru-RU`)
- `Referer` - Кто побудил браузер выполнить запрос (`https://google.com`)
- `Date` - Время генерации ответа веб-сервера (`Wed, 27, 1970`)
- `Content-type` - тип в формате MiMe ([[Одиннадцатый|смотреть здесь]]) 
- `Content-Length` - размер в байтах
- `Last-Modified` - Время последнего изменения, кэширования (`Mar, 16, 2004`)

# Защита от повторной отправки форм
- **CSRF-токен**. Это случайно сгенерированная строка, которая привязывается к пользовательской сессии и проверяется на сервере при каждой отправке формы. Если токен не соответствует ожидаемому значению, то запрос на сервер не будет выполнен.
- **Использование временных меток**. Если время между двумя отправками формы меньше заданного интервала, то запрос на сервер не будет выполнен.
- **Использование редиректа?** Вроде Ференец про что-то такое говорил. При отправке формы отправляешь пользователя на страницу success или failed условно. Как вариант? Возможно, это неверная инфа...
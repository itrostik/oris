---
title: десятый
---
# Билет
Шаблоны проектирования и архитектуры. MVC (опционально MVP, MVVM). Бизнес-логика. Слои/уровни абстракции. Шаблона проектирования (суть, когда применять и примеры использования в конкретных ситуациях): Data Mapper, Active Record, Listener (+ EDD), Decorator, Singlton, Iterator, Adapter, Facade, Builder, Abstract Factory, Dependency Injection.

> Вот теперь точно ебал

# Архитектура

## Бизнес-логика
Бля, как бы объяснить

В общем, это как логика приложения. Ну то есть допустим у нас есть музыкальный сервис. Пользователь лайкнул трек. Прокрутилась красивая анимация - это визуальная часть. На это действие прописана какая-то логика. Например, добавление трека в плейлист любимое, изменение рекомендаций и тд. Все это бизнес-логика
## MVC
Разделяет приложения на три основных компонента
- Model - представляет данные и реагирует на команды контроллера
- View - отвечает за отображение данных модели пользователю
- Controller - интерпретирует действия пользователя, оповещая модель о необходимости изменения

Основная цель применения этой концепции состоит в отделении бизнес-логики (модели) от её визуализации (представления, вида)

### Частая ошибка с MVC из википедии
Модель выступает исключительно совокупностью функций для доступа к данным, а контроллер хранит бизнес-логику. Но это неправильно, так как модель - это не только доступ к данным, но и вся бизнес-логику. Контроллеры же ответственны за прием запроса от пользователя, анализ запроса

# Проектирование
## Типы
- Структурные. Служат для того, чтобы добавлять функционал вашей системе, не затрагивая уже имеющиеся объекты
- Порождающие. Те паттерны, которые позволяют нам создавать какие-то объекты или классы.
- Поведенческие. Служат для того, чтобы налаживать связь между уже существующими объектами, классами, сущностями и т.д.
## Data Mapper
Также известный как ORM

Основная задача Data Mapper — разделить бизнес-логику приложения и логику взаимодействия с базой данных. Этот паттерн предоставляет отдельный слой для выполнения операций с данными и избавляет бизнес-объекты от необходимости заботиться о деталях хранения и извлечения данных из базы данных.

Короче, суть в том, что создаем "отдельный класс", который отвечает за работу с бд и связывает бизнес-класс с бд. То есть вместо того, чтобы писать SQL-скрипты в каждом месте где это нужно нам, мы опишем их в одном классе и потом будем дергать с помощью методов.

Этот паттерн позволяет не задумываться о том, как писать SQL-скрипты, так как все происходит на языке программирования. Также это позволяет отслеживать типы данных. Например можно написать такую функцию, которая будет принимать исключительно `int` и следовательно туда не получится передать `boolean`. Если бы не было этой прослойки, SQL-скрипты не были бы защищены от неверных типов данных

Лучший пример - это `Prisma` или любая другая ORM-система
## Active Record
Предлагает связывать объекты с записями в базе данных, делая объекты ответственными за собственное сохранение и загрузку данных. Он обеспечивает прямое соответствие между таблицами в базе данных и классами в коде.

Тут важно понимать разницу между Data Mapper и Active Record
- Data Mapper говорит: есть класс `User`, где хранится инфа про юзера и его методы, не связанные с бд и есть класс `UserMapper` - который отвечает за работу с бд, то есть вытаскивание данных или наоборот сохранение данных
- Active Record говорит: есть только класс `User` и там происходит вся суета, включая работу с бд, методы не связанные с бд + инфа про юзера и тд

![[Pasted image 20240116135759.png]]
## Listener
Поведенческий. Обеспечивает механизм подписки на события и оповещения заинтересованных объектов о произошедших изменениях

- **Издатель** генерирует события, содержит список слушателей и уведомляет их об изменениях
- **Слушатель** определяет методы, которые слушатели должны реализовать для обработки событий

Самый наглядный пример - это слушатели в JS, когда ты подписываешься на событие клика на кнопку и когда событие произойдет выполняешь определенные действия
## Decorator
Структурный. Позволяет динамически добавлять объектам новые функциональные возможности, оборачивая их в специальные классы-декораторы. Этот паттерн предоставляет гибкую альтернативу наследованию для расширения функциональности.

Примером можно считать фокусы с InputStream и тд в Java. Если сильно обобщить, то допустим мы хотим расширить функционал класса 1, то мы внутрь класса 2 принимаем класс 1 и работаем уже с ним

Декораторы позволяют создавать многофункциональные и расширяемые классы
## Singleton
Порождающий. Предоставляет механизм создания объекта так, чтобы у него был только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.

Короче, суть в том, что был только один экземляр класса всегда и везде. Для этого перед получением экземпляра класса мы проверяем, не создан ли он до этого. Если создан, то возвращаем его, если не создан, то создаем и возвращаем
## Iterator
Поведенческий. Предоставляет механизм последовательного доступа к элементам составного объекта без раскрытия его внутреннего представления.

Ну хз, вроде все понятно. Вкратце ты просишь итератор дать тебе следующий элемент (`next()`), если такая возможность есть, то он его возвращает. Также можно сделать функционал проверки, а можно ли вообще получить следующий элемент (`has()`)
## Adapter
Структурный. Позволяет объектам с несовместимыми интерфейсами работать вместе. Адаптер оборачивает один из объектов и предоставляет стандартный интерфейс для взаимодействия с другим объектом

пока хз, вроде все понятно, но кратенько объяснить не могу
## Facade
Структурный. Предоставляет унифицированный интерфейс для набора интерфейсов в подсистеме. Фасад определяет высокоуровневый интерфейс, упрощающий взаимодействие клиента с подсистемой, делая её более понятной и легкой в использовании.

Короче, есть несколько классов с разным функционалом. Их можно объединить в один единый с помощью фасада. То есть дергая фасад, он будет дергать дальше другие классы при необходимости. В целом, упрощение для работы с большой системой. Интуитивная хуйня
## Builder
Порождающий. Используется для создания сложных объектов шаг за шагом. Он позволяет создавать различные конфигурации объекта, изолируя процесс конструирования и предоставляя более гибкий и удобный способ создания сложных структур.

Буквально класс, который как-то настраивает определенный другой класс
## Abstract Factory
Порождающий. Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, без указания их конкретных классов. Этот паттерн позволяет создавать объекты семейства продуктов, соблюдая принцип инкапсуляции и обеспечивая легкость замены одного семейства продуктов другим

```js
// Абстрактные продукты
class Button {
  click() {}
}

class Checkbox {
  check() {}
}

// Абстрактная фабрика
class GUIFactory {
  createButton() {}
  createCheckbox() {}
}

// Конкретные продукты
class WindowsButton extends Button {
  click() {
    console.log('Windows button clicked');
  }
}

class MacOSButton extends Button {
  click() {
    console.log('MacOS button clicked');
  }
}

class WindowsCheckbox extends Checkbox {
  check() {
    console.log('Windows checkbox checked');
  }
}

class MacOSCheckbox extends Checkbox {
  check() {
    console.log('MacOS checkbox checked');
  }
}

// Конкретные фабрики
class WindowsFactory extends GUIFactory {
  createButton() {
    return new WindowsButton();
  }

  createCheckbox() {
    return new WindowsCheckbox();
  }
}

class MacOSFactory extends GUIFactory {
  createButton() {
    return new MacOSButton();
  }

  createCheckbox() {
    return new MacOSCheckbox();
  }
}
```

## Dependency Injection
Предполагает внедрение зависимостей объекта извне, вместо создания их внутри самого объекта. Это обеспечивает более гибкую и тестируемую архитектуру приложения. Интуитивная хуйня

```js
// Пример зависимости, которую мы хотим внедрить
class Logger {
  log(message) {
    console.log(message);
  }
}

// Пример класса, который использует зависимость через Dependency Injection
class ProductService {
  constructor(logger) {
    this.logger = logger;
  }

  getProduct(id) {
    // Логика получения продукта
    this.logger.log(`Запрошен продукт с ID ${id}`);
    // Возвращаем какой-то результат
    return { id, name: 'Example Product' };
  }
}
```
# Паттерны. Шаблоны проектирования

Шаблоны проектирования - некоторые структурные единицы, которые предназначены для решения часто встречаемых задач. Если обобщить, то паттерны делятся на три большие группы:
1. Структурные. Служат для того, чтобы добавлять функционал вашей системе, не затрагивая уже имеющиеся объекты
2. Порождающие. Те паттерны, которые позволяют нам создавать какие-то объекты или классы.
3. Поведенческие. Служат для того, чтобы налаживать связь между уже существующими объектами, классами, сущностями и т.д.

## Singleton
порождающий паттерн. Этот паттерн гарантирует, что у класса есть только один объект (экземпляр класса), к которому есть какая-то глобальная точка доступа.
Примеры:
1. "Персонаж" в компьютерной игре
2. Корзина интернет-магазина
3. Карта клиента
4. Объект, который работает с БД (если вам нужен доступ к БД из разных частей программы)

### Пример применения паттерна Singleton на JavaScript
*да-да, не на Java, потому что я фронтендер, реализую на чём удобнее*

1. Создаём класс `Database`, в котором создаём конструктор. Дальше проверяем, если у нашего класса уже есть `instanse`, то можно выплёвываться и просто вернуть текущий. Если же нет, то создаём и записываем туда данные. Также создадим метод `getData`, который возвращает данные нашего `instanse`

```javascript
class Database {  
  constructor(data) {  
    if (Database.instanse) {  
      return Database.instanse  
    }  
    Database.instanse = this  
    this.data = data  
  }  
  
  getData() {  
    return this.data  
  }  
}
```

2. Теперь попробуем создать объекты и посмотреть на результат

```javascript
const postgres = new Database('Postgres')  
const mongo = new Database('Mongo')  
console.log(postgres.getData())  
console.log(mongo.getData())
```

3. В консоли получаем:

```
Postgres
Postgres
```

Такое поведение может быть не логично, но с точки зрения Singleton всё с кайфом

## Factory
порождающий паттерн. Используется, когда нам нужно создавать множество однотипных объектов, то есть объекты с одной структурой, но разными данными. Эти объекты могут содержать как свойства, так и методы. Фабричный метод обычно содержит 2 класса: класс конструктор и класс (фабрика), который этот конструктор вызывает, передавая туда нужные данные. Рассмотрим пример на машинах BMW

1. Создаём класс конструктор:

```javascript
class Bmw {
	constructor(model, price, maxSpeed) {
		this.model = model;
		this.price = price;
		this.maxSpeed = maxSpeed
	}
}
```

2. А теперь создаём так называемый фабричный класс (фабрика), который будет нашей надстройкой и оптимизирует процесс создания.

```javascript
class BmwFactory {
	create(type) {
		if (type === 'X5') return new Bmw(type, 108000, 300)
		if (type === 'X6') return new Bmw(type, 111000, 320)
	}
}
```

3. Теперь мы можем создать экземпляр фабрики и обращаться к нему

```javascript
const factory = new BmwFactory()

const x5 = factory.create('X5')
const x6 = factory.create('X6')
```

Минус этого паттерна в том, что когда у нас будет много объектов, то наш фабричный класс будет разрастаться что не в себя, и тогда на помощь приходит паттерн Абстрактной Фабрики.

## Abstract Factory
порождающий паттерн. Паттерн, создающий интерфейс, группирующий другие фабрики, которые логически связаны друг с другом. Другими словами, это некая абстракция для фабрики и фабричного метода. Короче, абстрактная фабрика - надстройка над другими фабриками. Но есть нюанс, у этих "подфабрик" должен быть один интерфейс создания объектов, чтобы можно было управлять ими из абстрактной фабрики.

Если мало что понятно, то поздравляю, дальше станет ещё не понятнее. 
Ну а мы переходим к примеру на тех же машинах BMW. Зачем нам вообще понадобилась ещё одна надстройка над фабриками? Ну допустим, у нас до этого создавались только спортивные машины и мы написали фабрику для этого типа машин, но вдруг появился ещё один тип: "семейные машины". А потом ещё один тип и так далее. Не будем же мы писать общую фабрику для всех типов машин, учитывая что в конечном то итоге у нас экземпляр машины так же имеет модель, цену и максимальную скорость, то есть интерфейс создания объектов у нас один и тот же. В общем, пора кодить:

1. Создаём ту самую "Абстрактную фабрику"
```javascript
class BMWProducer { 
	produce(kind) { 
		return kind === 'sport' ? new SportCarFactory() : new FamilyCarFactory()
	}
}
```
2. Дальше создаём наши фабрики
```javascript
class SportCarFactory { 
	createCar() {
		return new Z4()
	}
}
class FamilyCarFactory {
	createCar() {
		return new I3()
	}
}
```
3. Ну и сами классы тоже
```javascript
class Z4 {
	info() {
		return "Z4 is a Sport car!"
	}
}
class I3 {
	info() {
		return 'I3 is a Family car!'
	}
}
```
4. Ну и теперь если нам нужен спорт-кар
```javascript
//создаём абстрактную фабрику, передавая туда то, что мы хотим получить
const bmwProducer = new BMWProducer()
//вызываем метод produce, получаем конкретную фабрику, в зависимости от переданного аргумента
const produce = bmwProducer.produce('sport')
//здесь мы и получаем нашу машину
const myCar = produce.createCar()
```

Абстрактная фабрика (BMWProducer) создает экземпляр нужной фабрики в зависимости от переданного вида ('sport' или 'family'). Фабрики (SportCarFactory и FamilyCarFactory) создают соответствующие автомобили (Z4 и I3).
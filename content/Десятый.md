---
title: десятый
---
# Билет
Шаблоны проектирования и архитектуры. MVC (опционально MVP, MVVM). Бизнес-логика. Слои/уровни абстракции. Шаблона проектирования (суть, когда применять и примеры использования в конкретных ситуациях): Data Mapper, Active Record, Listener (+ EDD), Decorator, Singlton, Iterator, Adapter, Facade, Builder, Abstract Factory, Dependency Injection.

> а вот шаблоны я ебал

# EDD
Парадигма программирования, в которой ход выполнение программы определяется сообщениями (событиями) от программных модулей, пользователя и других источников


# Паттерны. Шаблоны проектирования

Шаблоны проектирования - некоторые структурные единицы, которые предназначены для решения часто встречаемых задач. Если обобщить, то паттерны делятся на три большие группы:
1. Структурные. Служат для того, чтобы добавлять функционал вашей системе, не затрагивая уже имеющиеся объекты
2. Порождающие. Те паттерны, которые позволяют нам создавать какие-то объекты или классы.
3. Поведенческие. Служат для того, чтобы налаживать связь между уже существующими объектами, классами, сущностями и т.д.

## Singleton
порождающий паттерн. Этот паттерн гарантирует, что у класса есть только один объект (экземпляр класса), к которому есть какая-то глобальная точка доступа.
Примеры:
1. "Персонаж" в компьютерной игре
2. Корзина интернет-магазина
3. Карта клиента
4. Объект, который работает с БД (если вам нужен доступ к БД из разных частей программы)

### Пример применения паттерна Singleton на JavaScript
*да-да, не на Java, потому что я фронтендер, реализую на чём удобнее*

1. Создаём класс `Database`, в котором создаём конструктор. Дальше проверяем, если у нашего класса уже есть `instanse`, то можно выплёвываться и просто вернуть текущий. Если же нет, то создаём и записываем туда данные. Также создадим метод `getData`, который возвращает данные нашего `instanse`

```javascript
class Database {  
  constructor(data) {  
    if (Database.instanse) {  
      return Database.instanse  
    }  
    Database.instanse = this  
    this.data = data  
  }  
  
  getData() {  
    return this.data  
  }  
}
```

2. Теперь попробуем создать объекты и посмотреть на результат

```javascript
const postgres = new Database('Postgres')  
const mongo = new Database('Mongo')  
console.log(postgres.getData())  
console.log(mongo.getData())
```

3. В консоли получаем:

```
Postgres
Postgres
```

Такое поведение может быть не логично, но с точки зрения Singleton всё с кайфом

## Factory
порождающий паттерн. Используется, когда нам нужно создавать множество однотипных объектов, то есть объекты с одной структурой, но разными данными. Эти объекты могут содержать как свойства, так и методы. Фабричный метод обычно содержит 2 класса: класс конструктор и класс (фабрика), который этот конструктор вызывает, передавая туда нужные данные. Рассмотрим пример на машинах BMW

1. Создаём класс конструктор:

```javascript
class Bmw {
	constructor(model, price, maxSpeed) {
		this.model = model;
		this.price = price;
		this.maxSpeed = maxSpeed
	}
}
```

2. А теперь создаём так называемый фабричный класс (фабрика), который будет нашей надстройкой и оптимизирует процесс создания.

```javascript
class BmwFactory {
	create(type) {
		if (type === 'X5') return new Bmw(type, 108000, 300)
		if (type === 'X6') return new Bmw(type, 111000, 320)
	}
}
```

3. Теперь мы можем создать экземпляр фабрики и обращаться к нему

```javascript
const factory = new BmwFactory()

const x5 = factory.create('X5')
const x6 = factory.create('X6')
```

Минус этого паттерна в том, что когда у нас будет много объектов, то наш фабричный класс будет разрастаться что не в себя, и тогда на помощь приходит паттерн Абстрактной Фабрики.

## Abstract Factory
порождающий паттерн. Паттерн, создающий интерфейс, группирующий другие фабрики, которые логически связаны друг с другом. Другими словами, это некая абстракция для фабрики и фабричного метода. Короче, абстрактная фабрика - надстройка над другими фабриками. Но есть нюанс, у этих "подфабрик" должен быть один интерфейс создания объектов, чтобы можно было управлять ими из абстрактной фабрики.

Если мало что понятно, то поздравляю, дальше станет ещё не понятнее. 
Ну а мы переходим к примеру на тех же машинах BMW. Зачем нам вообще понадобилась ещё одна надстройка над фабриками? Ну допустим, у нас до этого создавались только спортивные машины и мы написали фабрику для этого типа машин, но вдруг появился ещё один тип: "семейные машины". А потом ещё один тип и так далее. Не будем же мы писать общую фабрику для всех типов машин, учитывая что в конечном то итоге у нас экземпляр машины так же имеет модель, цену и максимальную скорость, то есть интерфейс создания объектов у нас один и тот же. В общем, пора кодить:

1. Создаём ту самую "Абстрактную фабрику"
```javascript
class BMWProducer { 
	produce(kind) { 
		return kind === 'sport' ? new SportCarFactory() : new FamilyCarFactory()
	}
}
```
2. Дальше создаём наши фабрики
```javascript
class SportCarFactory { 
	createCar() {
		return new Z4()
	}
}
class FamilyCarFactory {
	createCar() {
		return new I3()
	}
}
```
3. Ну и сами классы тоже
```javascript
class Z4 {
	info() {
		return "Z4 is a Sport car!"
	}
}
class I3 {
	info() {
		return 'I3 is a Family car!'
	}
}
```
4. Ну и теперь если нам нужен спорт-кар
```javascript
//создаём абстрактную фабрику, передавая туда то, что мы хотим получить
const bmwProducer = new BMWProducer()
//вызываем метод produce, получаем конкретную фабрику, в зависимости от переданного аргумента
const produce = bmwProducer.produce('sport')
//здесь мы и получаем нашу машину
const myCar = produce.createCar()
```

Абстрактная фабрика (BMWProducer) создает экземпляр нужной фабрики в зависимости от переданного вида ('sport' или 'family'). Фабрики (SportCarFactory и FamilyCarFactory) создают соответствующие автомобили (Z4 и I3).
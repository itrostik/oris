---
title: десятый
---
# Билет
Шаблоны проектирования и архитектуры. MVC (опционально MVP, MVVM). Бизнес-логика. Слои/уровни абстракции. Шаблона проектирования (суть, когда применять и примеры использования в конкретных ситуациях): Data Mapper, Active Record, Listener (+ EDD), Decorator, Singlton, Iterator, Adapter, Facade, Builder, Abstract Factory, Dependency Injection.

> Вот теперь точно ебал

# Архитектура

## Бизнес-логика
Бля, как бы объяснить

В общем, это как логика приложения. Ну то есть допустим у нас есть музыкальный сервис. Пользователь лайкнул трек. Прокрутилась красивая анимация - это визуальная часть. На это действие прописана какая-то логика. Например, добавление трека в плейлист любимое, изменение рекомендаций и тд. Все это бизнес-логика
## MVC
Разделяет приложения на три основных компонента
- Model - представляет данные и реагирует на команды контроллера
- View - отвечает за отображение данных модели пользователю
- Controller - интерпретирует действия пользователя, оповещая модель о необходимости изменения

Основная цель применения этой концепции состоит в отделении бизнес-логики (модели) от её визуализации (представления, вида)

### Частая ошибка с MVC из википедии
Модель выступает исключительно совокупностью функций для доступа к данным, а контроллер хранит бизнес-логику. Но это неправильно, так как модель - это не только доступ к данным, но и вся бизнес-логику. Контроллеры же ответственны за прием запроса от пользователя, анализ запроса

# Проектирование
## Типы
- Структурные. Служат для того, чтобы добавлять функционал вашей системе, не затрагивая уже имеющиеся объекты
- Порождающие. Те паттерны, которые позволяют нам создавать какие-то объекты или классы.
- Поведенческие. Служат для того, чтобы налаживать связь между уже существующими объектами, классами, сущностями и т.д.
## Data Mapper
Также известный как ORM

Основная задача Data Mapper — разделить бизнес-логику приложения и логику взаимодействия с базой данных. Этот паттерн предоставляет отдельный слой для выполнения операций с данными и избавляет бизнес-объекты от необходимости заботиться о деталях хранения и извлечения данных из базы данных.

Короче, суть в том, что создаем "отдельный класс", который отвечает за работу с бд и связывает бизнес-класс с бд. То есть вместо того, чтобы писать SQL-скрипты в каждом месте где это нужно нам, мы опишем их в одном классе и потом будем дергать с помощью методов.

Этот паттерн позволяет не задумываться о том, как писать SQL-скрипты, так как все происходит на языке программирования. Также это позволяет отслеживать типы данных. Например можно написать такую функцию, которая будет принимать исключительно `int` и следовательно туда не получится передать `boolean`. Если бы не было этой прослойки, SQL-скрипты не были бы защищены от неверных типов данных

Лучший пример - это `Prisma` или любая другая ORM-система
## Active Record
Предлагает связывать объекты с записями в базе данных, делая объекты ответственными за собственное сохранение и загрузку данных. Он обеспечивает прямое соответствие между таблицами в базе данных и классами в коде.

Тут важно понимать разницу между Data Mapper и Active Record
- Data Mapper говорит: есть класс `User`, где хранится инфа про юзера и его методы, не связанные с бд и есть класс `UserMapper` - который отвечает за работу с бд, то есть вытаскивание данных или наоборот сохранение данных
- Active Record говорит: есть только класс `User` и там происходит вся суета, включая работу с бд, методы не связанные с бд + инфа про юзера и тд

![[Pasted image 20240116135759.png]]
## Listener
Поведенческий. Обеспечивает механизм подписки на события и оповещения заинтересованных объектов о произошедших изменениях

- **Издатель** генерирует события, содержит список слушателей и уведомляет их об изменениях
- **Слушатель** определяет методы, которые слушатели должны реализовать для обработки событий

Самый наглядный пример - это слушатели в JS, когда ты подписываешься на событие клика на кнопку и когда событие произойдет выполняешь определенные действия
## Decorator
Структурный. Позволяет динамически добавлять объектам новые функциональные возможности, оборачивая их в специальные классы-декораторы. Этот паттерн предоставляет гибкую альтернативу наследованию для расширения функциональности.

Примером можно считать фокусы с InputStream и тд в Java. Если сильно обобщить, то допустим мы хотим расширить функционал класса 1, то мы внутрь класса 2 принимаем класс 1 и работаем уже с ним

Декораторы позволяют создавать многофункциональные и расширяемые классы
## Singleton
Порождающий. Предоставляет механизм создания объекта так, чтобы у него был только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.

Короче, суть в том, что был только один экземляр класса всегда и везде. Для этого перед получением экземпляра класса мы проверяем, не создан ли он до этого. Если создан, то возвращаем его, если не создан, то создаем и возвращаем
## Iterator
Поведенческий. Предоставляет механизм последовательного доступа к элементам составного объекта без раскрытия его внутреннего представления.

Ну хз, вроде все понятно. Вкратце ты просишь итератор дать тебе следующий элемент (`next()`), если такая возможность есть, то он его возвращает. Также можно сделать функционал проверки, а можно ли вообще получить следующий элемент (`has()`)
## Adapter
Структурный. Позволяет объектам с несовместимыми интерфейсами работать вместе. Адаптер оборачивает один из объектов и предоставляет стандартный интерфейс для взаимодействия с другим объектом

пока хз, вроде все понятно, но кратенько объяснить не могу
## Facade
Структурный. Предоставляет унифицированный интерфейс для набора интерфейсов в подсистеме. Фасад определяет высокоуровневый интерфейс, упрощающий взаимодействие клиента с подсистемой, делая её более понятной и легкой в использовании.

Короче, есть несколько классов с разным функционалом. Их можно объединить в один единый с помощью фасада. То есть дергая фасад, он будет дергать дальше другие классы при необходимости. В целом, упрощение для работы с большой системой. Интуитивная хуйня
## Builder
Порождающий. Используется для создания сложных объектов шаг за шагом. Он позволяет создавать различные конфигурации объекта, изолируя процесс конструирования и предоставляя более гибкий и удобный способ создания сложных структур.

Буквально класс, который как-то настраивает определенный другой класс
## Abstract Factory
Порождающий. Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, без указания их конкретных классов. Этот паттерн позволяет создавать объекты семейства продуктов, соблюдая принцип инкапсуляции и обеспечивая легкость замены одного семейства продуктов другим

```js
// Абстрактные продукты
class Button {
  click() {}
}

class Checkbox {
  check() {}
}

// Абстрактная фабрика
class GUIFactory {
  createButton() {}
  createCheckbox() {}
}

// Конкретные продукты
class WindowsButton extends Button {
  click() {
    console.log('Windows button clicked');
  }
}

class MacOSButton extends Button {
  click() {
    console.log('MacOS button clicked');
  }
}

class WindowsCheckbox extends Checkbox {
  check() {
    console.log('Windows checkbox checked');
  }
}

class MacOSCheckbox extends Checkbox {
  check() {
    console.log('MacOS checkbox checked');
  }
}

// Конкретные фабрики
class WindowsFactory extends GUIFactory {
  createButton() {
    return new WindowsButton();
  }

  createCheckbox() {
    return new WindowsCheckbox();
  }
}

class MacOSFactory extends GUIFactory {
  createButton() {
    return new MacOSButton();
  }

  createCheckbox() {
    return new MacOSCheckbox();
  }
}
```

## Dependency Injection
Предполагает внедрение зависимостей объекта извне, вместо создания их внутри самого объекта. Это обеспечивает более гибкую и тестируемую архитектуру приложения. Интуитивная хуйня

```js
// Пример зависимости, которую мы хотим внедрить
class Logger {
  log(message) {
    console.log(message);
  }
}

// Пример класса, который использует зависимость через Dependency Injection
class ProductService {
  constructor(logger) {
    this.logger = logger;
  }

  getProduct(id) {
    // Логика получения продукта
    this.logger.log(`Запрошен продукт с ID ${id}`);
    // Возвращаем какой-то результат
    return { id, name: 'Example Product' };
  }
}
```
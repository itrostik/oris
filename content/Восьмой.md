---
title: восьмой
---
# Билет
GUI. Сравнение AWT, Swing, JavaFX. FXML и MVC для JavaFX. JavaFX: что такое компонент, как создать окно, как добавить компоненты в окно, распределение компонент внутри родителя (layout) (Border + пара любых других примеров), как прикрепить контроллер в JavaFX, основные идеи работы с потоками.

Мое скромное мнение - это точно скип
# GUI
## Определение
Интерфейс машины для человека, основанный на графических элементах
## Из чего состоит
- Компоненты
	- Управляющие элементы
	- Каркас (Layout)
	- Медиа
- Подписка на события
- Рисование и анимация
- Управление потоками
- Интеграция 
- Стили
# Сравнение AWT, Swing, JavaFX
AWT (Abstract Window Toolkit) - это первый набор инструментов для создания графических пользовательских интерфейсов (GUI) в Java. Он предоставляет низкоуровневые компоненты, такие как кнопки, текстовые поля и окна, которые могут быть использованы для создания пользовательских интерфейсов. Однако AWT имеет некоторые ограничения, такие как отсутствие поддержки прозрачности и возможности настройки внешнего вида элементов.

Swing - это более современный и гибкий набор инструментов для создания GUI в Java. Он предоставляет более высокоуровневые компоненты, такие как таблицы, деревья и вкладки, а также поддерживает прозрачность и настраиваемый внешний вид элементов. Swing также имеет более широкий набор функций и более легко расширяем, чем AWT.

JavaFX - это новый набор инструментов для создания GUI в Java, который был представлен в 2008 году. JavaFX предоставляет более современные и мощные возможности для создания интерактивных приложений, таких как анимация, 3D-графика и мультимедиа. Он также имеет более простой и интуитивный API, чем Swing, и может быть использован как для создания настольных приложений, так и для разработки веб-приложений.

# JavaFX
## Определение
Инструментарий для работы с GUI в Java
## Особенности
- JavaFX изначально поставляется с большим набором частей графического интерфейса, таких как всякие там кнопки, текстовые поля, таблицы, деревья, меню, диаграммы
- JavaFX часто юзает стили CSS, и мы сможем использовать специальный формат FXML для создания GUI, а не делать это в коде Java
- JavaFX дополнительно поставляется с поддержкой 3D графики, которая часто полезна, если мы разрабатываем какую-то игру или подобные приложения
## Основные определения
- Stage — по сути это окружающее окно, которое используется как начальное полотно и содержит в себе остальные компоненты. У приложения может быть несколько stage, но один такой компонент должен быть в любом случае. По сути Stage является основным контейнером и точкой входа.
- Scene — отображает содержание stage (прям матрёшка). Каждый stage может содержать несколько компонентов — scene, которые можно между собой переключать. Внутри это реализуется графом объектов, который называется — Scene Graph (где каждый элемент — узел, ещё называемый как Node). Устанавливается сцена методом Stage.setScene(Scene scene)
- Node — это элементы управления, например, кнопки метки, или даже макеты (layout), внутри которых может быть несколько вложенных компонентов. У каждой сцены (scene) может быть один вложенный узел (node), но это может быть макет (layout) с несколькими компонентами. Вложенность может быть многоуровневой, когда макеты содержат другие макеты и обычные компоненты. У каждого такого узла есть свой идентификатор, стиль, эффекты, состояние, обработчики событий

![Введение в Java FX - 4](https://cdn.javarush.com/images/article/2336fb03-028b-4d0f-af8c-dd5b20d01b18/512.webp)
## Пример
```java
public class Appl extends Application {
   public static void main(String[] args) {
       launch(args);
   }

   @Override
   public void start(Stage primaryStage) throws Exception {
       primaryStage.setTitle("Это Stage. Он включает в себя сцену");
       Group g = new Group();
       g.getChildren().add(new Label("Этот текст - корень сцены сцены.\n Сама сцена окрашена зеленым."));
       Scene s = new Scene(g, 400, 40, Color.GREEN);
       primaryStage.setScene(s);
       primaryStage.show();
       
       Stage stage = new Stage();
       stage.setTitle("Это 2ой Stage.");
       stage.setScene(new Scene(new Group(),400, 40, Color.GREEN));
       stage.show();
   }
}
```

![](https://lh7-us.googleusercontent.com/a3wAGwycoBvcCf_2kXXPWHrLtWK9MKXeiEX5Y-VQOER1FxoFuSOAsATuUA1NO2PTAHduPjD4zeo1MYOz7n-nKpWvZL_DJXNj4M7ei-jYeFuTmkgvKK_E5A3AN8Mx5hOOb2aOWb-zZ85vnPMGnILVsg)

## Подписка на события, или обработка событий
Основным классом для всех событий является класс javafx.event.Event. От него уже наследуются более конкретные классы, например ActionEvent, который реагирует на некоторые типичные события, например, нажатие кнопки; KeyEvent - нажатие клавиши, MouseEvent - клик мышки, и другие Event-классы. Сам javafx.event.Event является наследником java.util.EventObject и имеет один метод handle(Event event), поэтому чаще всего задается лямбда-выражением.

У большинства элементов есть методы, которые соответствуют определенным событиям, и которые подписывают элемент на событие. Например setOnAction() у Button, setOnKeyPressed() у Scene и тд.

```java
Button button = new Button("Нажать");
button.setOnAction(event -> button.setText("Вы нажали"));
```

![](https://lh7-us.googleusercontent.com/x0Fqf_oZYA17mCvRPhxjufIh0IdnX6pgO83gyc0KhTsegEIBrP66FJKZHAAJ0W5TsuSLVLJ_jjuvjP7yKFIUFVtqQP6KktJa54kW_KujffB1x3r4fzFxnlKkIsxVx1TiEjSBZwfLC2HV4BTNeo0vkA)

![](https://lh7-us.googleusercontent.com/VIs11Awcz4r1PGCNXI9Ee9WRYu-cexgwGca4L7ra51MYQV7GAWHd5TfbCahz8dSxQKO-5nA0_hqk18w-PJiGhfwu32HmDtXFqomWXS7KsubFEt_gpU_WYdTtQlGP2mlcdfuVeBvGF877cZDEAmDhcg)

## Добавление элементов
У всех Parent-потомков есть список детей, в который можно положить новый элемент (У самого Parent есть getChildrenUnmodifiable() в который нельзя положить элементы, а метод getChildren() имеет модификатор protected).

```java
Group g = new Group();
g.getChildren().add(new Label("А"));
```

Group.getChildren() возвращает реализованный javafx.collections.ObservableList (коллекция с специфичными для FX методами), который является наследником List, метод add() добавляет элемент в коллекцию.

## Модальные окна
Модальные окна, это такие же обычные окна, создаются просто новым stage. Пример был выше с 2умя Stage. Существует 3 вида модальности:
1. Modality.NONE - новое окно, не зависит ни от кого и никого не блокирует
2. Modality.WINDOW_MODAL - новое окно, зависит от родительского окна. Блокируются действия с родительским окном до закрытия нового окна.
3. Modality.APPLICATION_MODAL - новое окно, зависит от приложения. Блокируются любые действия со всеми окнами кроме этого до его закрытия.

Назначить родительское окно можно методом ```
```java
Stage.InitOwner(Stage parentStage);
```

## FXML
Так как сцена строится древовидным образом, то формат xml прекрасно подходит для компоновки программы. Специфичным для JavaFx форматом является fxml. В нем можно определить все компоненты, их свойства, а также контроллер (о нем позже). О структуре fxml формата на лекции говорилось не так много, потому что в основном всё строится через SceneBuilder от Gluon. Для того чтобы распарсить fxml файл на дерево используется класс javafx.fxml.Loader. У него есть метод load() который распарсит переданный файл, построит по нему дерево и вернет корень этого дерева. 

Однако в fxml не получится привязать событие к элементам через методы, для этого придумали…

## Контроллеры
Контроллеры - это не какой то javafx класс, они ни от кого не наследуются. Это обычные классы, в которых всё строится на аннотациях. В этом классе с аннотациями @FXML описываются элементы javafx. Причем этим элементам в fxml файле должен соответствовать fx:id равный их идентификатору. То есть, пусть в контроллере есть аннотированный @FXML Button button, тогда в fxml файле для привязки к этому button должен быть элемент со свойством fx:id=”button”. Причем типы этих элементов также должны совпадать. Инициализировать аннотированные элементы в контроллере нельзя, только идентифицировать. Однако, чтобы привязать событие к элементу необходимо, чтобы он был инициализирован (иначе будет NullPointerException),  для этого в javafx.fxml есть интерфейс Initializable с 1 методом initialize(). Контроллеры которые имплементируют этот интерфейс, говорят, что в методе initialize() все используемые внутри переменные будут инициализированы FXMLLoader’ом до запуска метода(Не все переменные в классе контроллера, а все внутри initialize()). 

## Привязка контроллера и стилей к сцене
(На самом деле контроллер можно привязать к любому контейнеру, например Group или Pane, так как FXMLLoader необязательно должен возвращать Scene. Так же хз че имеется в виду под привязкой стилей к сцене, возможно загрузка stylesheet’ов или что то такое)

Привязывается контроллер к Scene или к Group или к Region и тд обычным свойством fx:controller=”путь к классу контроллера”. Стили привязываются как свойства(работает как в HTML, пишется style=”стиль: значение”, например style="-fx-background-color: red"), однако в контейнере Group стили не работают, так же как и layout'ы. Также существуют классы стилей, селекторы, кастомные классы, работают аналогично html, задаются styleClass=”some-style-class”. Сами собой стили это цвет, шрифт, размер шрифта, задний фон, поворот, обводка, прозрачность и тд и тп. 

Наиболее используемый формат - fxml, так как его написание очень легко автоматизируется, так как fxml не имеет логики. Однако fxml тяжело использовать при создании каких либо массивов элементов(Например, чтобы создать 10 кнопок в SceneBuilder придется создать 10 кнопок, всем этим кнопкам задать id и пометить их в контроллере), поэтому и не только поэтому в контроллерах создаются элементы, которые не помечаются @FXML. Также часто совмещаются способы создания приложения классическим способом и fxml+controllers способом.
